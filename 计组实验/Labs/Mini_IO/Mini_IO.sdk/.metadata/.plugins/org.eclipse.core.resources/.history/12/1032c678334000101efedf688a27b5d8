#include "xil_io.h"
#include "stdio.h"
#include "xintc_l.h"
#include "xtmrctr_l.h"
#include "xgpio_l.h"

#define RESET_VALUE0 200000000 - 2 // 2s
#define RESET_VALUE1 100000000 - 2 // 1s
#define RESET_VALUE2 50000000 - 2 // 0.5s
#define RESET_VALUE3 25000000 - 2 // 0.25s
#define RESET_VALUE4 100000 - 2 // 1ms

void interruptHub(void)__attribute__((interrupt_handler));
void btnHandler(void);
void tmrHandler(void);
void tmr0Handler(void); // 频闪显示
void tmr1Handler(void); // 滚动显示

int loop = 0, pos = 0, i = 0;

u8 seg_code[17] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90,
			 	   0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e, 0xff};
u8 pos_code[8] = {0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0xfe};

int main()
{
	// GPIO 输入/输出配置
	Xil_Out16(XPAR_AXI_GPIO_2_BASEADDR + XGPIO_TRI_OFFSET, 0x1f); // 读取按钮状态
	Xil_Out16(XPAR_AXI_GPIO_1_BASEADDR + XGPIO_TRI_OFFSET, 0x0); // 输出数码管位选信号
	Xil_Out16(XPAR_AXI_GPIO_1_BASEADDR + XGPIO_TRI2_OFFSET, 0x0); // 输出数码管段选信号

	// GPIO 中断配置
	Xil_Out32(XPAR_AXI_GPIO_2_BASEADDR + XGPIO_ISR_OFFSET, 0x1); // 清除GPIO_2的通道1（按钮）的中断状态
	Xil_Out32(XPAR_AXI_GPIO_2_BASEADDR + XGPIO_IER_OFFSET, 0x1); // 使能通道1中断
	Xil_Out32(XPAR_AXI_GPIO_2_BASEADDR + XGPIO_GIE_OFFSET, 0x80000000); // 使能中断输出

	// T0 初始化
	Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR+XTC_TCSR_OFFSET,
			  Xil_In32(XPAR_AXI_TIMER_0_BASEADDR+XTC_TCSR_OFFSET)&~XTC_CSR_ENABLE_TMR_MASK);
	Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR+XTC_TLR_OFFSET, RESET_VALUE4);
	Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR+XTC_TCSR_OFFSET,
			  Xil_In32(XPAR_AXI_TIMER_0_BASEADDR+XTC_TCSR_OFFSET) | XTC_CSR_LOAD_MASK);
	Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR+XTC_TCSR_OFFSET,
			  (Xil_In32(XPAR_AXI_TIMER_0_BASEADDR+XTC_TCSR_OFFSET)&~XTC_CSR_LOAD_MASK) |
			  XTC_CSR_ENABLE_TMR_MASK | XTC_CSR_AUTO_RELOAD_MASK | XTC_CSR_ENABLE_INT_MASK |
			  XTC_CSR_DOWN_COUNT_MASK);

	// T1初始化
	Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TIMER_COUNTER_OFFSET+XTC_TCSR_OFFSET,
			  Xil_In32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TIMER_COUNTER_OFFSET + XTC_TCSR_OFFSET) & ~XTC_CSR_ENABLE_TMR_MASK);
	Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TIMER_COUNTER_OFFSET + XTC_TLR_OFFSET, RESET_VALUE0);
	Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TIMER_COUNTER_OFFSET + XTC_TCSR_OFFSET,
			  Xil_In32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TIMER_COUNTER_OFFSET + XTC_TCSR_OFFSET) |
			  XTC_CSR_LOAD_MASK);
	Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TIMER_COUNTER_OFFSET + XTC_TCSR_OFFSET,
			  (Xil_In32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TIMER_COUNTER_OFFSET + XTC_TCSR_OFFSET) & ~XTC_CSR_LOAD_MASK) |
			  XTC_CSR_ENABLE_TMR_MASK | XTC_CSR_AUTO_RELOAD_MASK | XTC_CSR_ENABLE_INT_MASK |
			  XTC_CSR_DOWN_COUNT_MASK);

	// INTC初始化
	Xil_Out32(XPAR_AXI_INTC_0_BASEADDR + XIN_IAR_OFFSET, 0xffffffff); // 清除所有通道的中断状态
	Xil_Out32(XPAR_AXI_INTC_0_BASEADDR + XIN_IER_OFFSET,
			  XPAR_AXI_GPIO_2_IP2INTC_IRPT_MASK | XPAR_AXI_TIMER_0_INTERRUPT_MASK); // 使能按钮和T0中断
	Xil_Out32(XPAR_AXI_INTC_0_BASEADDR + XIN_MER_OFFSET, 0x3); // 使能硬件中断irq输出

	microblaze_enable_interrupts();
	return 0;
}

void interruptHub()
{
	int status;
	status = Xil_In32(XPAR_AXI_INTC_0_BASEADDR + XIN_ISR_OFFSET);

	if ((status & XPAR_AXI_GPIO_2_IP2INTC_IRPT_MASK) == XPAR_AXI_GPIO_2_IP2INTC_IRPT_MASK)
	{
		btnHandler();
	}
	if ((status & XPAR_AXI_TIMER_0_INTERRUPT_MASK) == XPAR_AXI_TIMER_0_INTERRUPT_MASK)
	{
		tmrHandler();
	}

	Xil_Out32(XPAR_AXI_INTC_0_BASEADDR+XIN_IAR_OFFSET, status);
}

void tmrHandler()
{
	int tcsr;
	tcsr = Xil_In32(XPAR_AXI_TIMER_0_BASEADDR+XTC_TCSR_OFFSET);
	if((tcsr & XTC_CSR_INT_OCCURED_MASK) == XTC_CSR_INT_OCCURED_MASK)
	{
		tmr0Handler();
		Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TCSR_OFFSET,
				  Xil_In32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TCSR_OFFSET));
	}

	tcsr = Xil_In32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TIMER_COUNTER_OFFSET + XTC_TCSR_OFFSET);
	if((tcsr & XTC_CSR_INT_OCCURED_MASK) == XTC_CSR_INT_OCCURED_MASK)
	{
		tmr1Handler();
		Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TIMER_COUNTER_OFFSET + XTC_TCSR_OFFSET,
			      Xil_In32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TIMER_COUNTER_OFFSET + XTC_TCSR_OFFSET));
	}
}

void tmr0Handler()
{
	Xil_Out32(XPAR_GPIO_1_BASEADDR + XGPIO_DATA_OFFSET, pos_code[pos]);
	Xil_Out32(XPAR_GPIO_1_BASEADDR + XGPIO_DATA2_OFFSET, seg_code[(loop + pos) % 4]);

	pos++;
	if (pos == 4)
	{
		pos = 0;
	}
}

void tmr1Handler()
{
	loop++;
	if (loop == 4)
	{
		loop = 0;
	}
}

void btnHandler()
{
	u8 btn_status = Xil_In8(XPAR_AXI_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET) & 0x1f;
	if (btn_status == 0x1)
	{
		switch(i)
		{
			case 0: Xil_Out32(XPAR_AXI_TIMER_1_BASEADDR + XTC_TLR_OFFSET, RESET_VALUE1); i++;
			break;
			case 1: Xil_Out32(XPAR_AXI_TIMER_1_BASEADDR+XTC_TLR_OFFSET,RESET_VALUE2); i++;
			break;
			case 2: Xil_Out32(XPAR_AXI_TIMER_1_BASEADDR+XTC_TLR_OFFSET,RESET_VALUE3); i++;
			break;
			case 3: Xil_Out32(XPAR_AXI_TIMER_1_BASEADDR+XTC_TLR_OFFSET,RESET_VALUE0); i++;
			break;
		}
		if (i == 4)
		{
			i = 0;
		}
	}

	Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TCSR_OFFSET,
			  Xil_In32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TCSR_OFFSET) | XTC_CSR_LOAD_MASK);
	Xil_Out32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TCSR_OFFSET,
			  (Xil_In32(XPAR_AXI_TIMER_0_BASEADDR + XTC_TCSR_OFFSET) &~ XTC_CSR_LOAD_MASK) |
			  XTC_CSR_ENABLE_TMR_MASK | XTC_CSR_AUTO_RELOAD_MASK | XTC_CSR_ENABLE_INT_MASK |
			  XTC_CSR_DOWN_COUNT_MASK);

	Xil_Out32(XPAR_AXI_GPIO_0_BASEADDR + XGPIO_ISR_OFFSET,
			  Xil_In32(XPAR_AXI_GPIO_0_BASEADDR + XGPIO_ISR_OFFSET));
}
